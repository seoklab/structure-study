name: Check Job Completion

on:
  # Disabled - competition ended
  # schedule:
  #   - cron: '*/5 * * * *'
  workflow_dispatch:

jobs:
  check-jobs:
    runs-on: [self-hosted, galaxy4]
    permissions:
      contents: write
      issues: write
    env:
      SUBMISSIONS_BASE: /data/galaxy4/user/j2ho/kidds2026/protein-competition/submissions
      PUBLIC_RESULTS: /data/galaxy4/user/j2ho/kidds2026/protein-competition/public_results
      SITE_URL: https://seoklab.github.io/structure-study
      # Set to "true" for notification after each problem
      # Set to "false" for single notification when all problems complete (default)
      INCREMENTAL_NOTIFICATIONS: "false"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check and package completed submissions
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RESULTS_UPDATED=false

          # Process all submissions (directories with status.json)
          for dir in ${SUBMISSIONS_BASE}/*/; do
            [ ! -d "$dir" ] && continue

            STATUS_FILE="${dir}status.json"
            [ ! -f "$STATUS_FILE" ] && continue

            # Read status
            STATUS=$(python3 -c "import json; print(json.load(open('$STATUS_FILE')).get('status', 'unknown'))" 2>/dev/null || echo "unknown")

            # Skip if already completed or notified_partial or notified_failed
            # Note: "packaged" status means results are ready but not yet in docs/results/ - don't skip
            [ "$STATUS" = "completed" ] || [ "$STATUS" = "notified_partial" ] || [ "$STATUS" = "notified_failed" ] && continue

            SUBMISSION_ID=$(basename "$dir")
            echo "Checking $SUBMISSION_ID (status: $STATUS)..."

            # Get submission info
            SUBMISSION_FILE="$dir/submission.json"
            PARTICIPANT_ID=$(python3 -c "import json; print(json.load(open('$SUBMISSION_FILE')).get('participant_id', 'unknown'))" 2>/dev/null || echo "unknown")
            ISSUE_NUMBER=$(python3 -c "import json; print(json.load(open('$SUBMISSION_FILE')).get('issue_number', ''))" 2>/dev/null || echo "")

            # Check for multi-problem submission
            PROBLEM_DIRS=$(find "$dir" -maxdepth 1 -type d -name "problem_*" 2>/dev/null | sort)
            PROBLEM_COUNT=0
            [ -n "$PROBLEM_DIRS" ] && PROBLEM_COUNT=$(echo "$PROBLEM_DIRS" | wc -l | tr -d ' ')

            if [ "$PROBLEM_COUNT" -gt 0 ]; then
              # Multi-problem submission
              TOTAL_PROBLEMS=$(python3 -c "import json; d=json.load(open('$SUBMISSION_FILE')); print(len(d.get('sequences', {})))" 2>/dev/null || echo "$PROBLEM_COUNT")

              # Get already notified problems from status
              NOTIFIED_PROBLEMS=$(python3 -c "import json; print(','.join(json.load(open('$STATUS_FILE')).get('notified_problems', [])))" 2>/dev/null || echo "")

              COMPLETED_LIST=""
              FAILED_LIST=""
              PENDING_LIST=""
              NEW_COMPLETED_LIST=""
              COMPLETED_COUNT=0
              FAILED_COUNT=0

              for problem_dir in $PROBLEM_DIRS; do
                [ ! -d "$problem_dir" ] && continue
                PROBLEM_ID=$(basename "$problem_dir")

                # Check for seq_* subdirectories (multi-sequence format)
                SEQ_DIRS=$(find "$problem_dir" -maxdepth 1 -type d -name "seq_*" 2>/dev/null | sort)
                SEQ_COUNT=0
                [ -n "$SEQ_DIRS" ] && SEQ_COUNT=$(echo "$SEQ_DIRS" | wc -l | tr -d ' ')

                if [ "$SEQ_COUNT" -gt 0 ]; then
                  # Multi-sequence: check each seq directory
                  PROBLEM_COMPLETED=0
                  PROBLEM_FAILED=0
                  PROBLEM_PENDING=0

                  for seq_dir in $SEQ_DIRS; do
                    [ ! -d "$seq_dir" ] && continue
                    SEQ_NUM=$(basename "$seq_dir" | sed 's/seq_//')

                    # Check for model.cif in seq directory
                    if find "$seq_dir" -maxdepth 2 -name "*_model.cif" -type f 2>/dev/null | head -1 | grep -q .; then
                      PROBLEM_COMPLETED=$((PROBLEM_COMPLETED + 1))
                    else
                      # Check SLURM job status
                      JOB_NAME="${SUBMISSION_ID}_${PROBLEM_ID}_seq${SEQ_NUM}"
                      JOB_STATUS=$(sacct --name="$JOB_NAME" --format=State --noheader 2>/dev/null | head -1 | tr -d ' ')

                      if [ "$JOB_STATUS" = "FAILED" ] || [ "$JOB_STATUS" = "CANCELLED" ] || [ "$JOB_STATUS" = "TIMEOUT" ]; then
                        PROBLEM_FAILED=$((PROBLEM_FAILED + 1))
                      else
                        PROBLEM_PENDING=$((PROBLEM_PENDING + 1))
                      fi
                    fi
                  done

                  # Problem is done when all sequences finished (completed or failed, none pending)
                  if [ "$PROBLEM_PENDING" -eq 0 ]; then
                    if [ "$PROBLEM_COMPLETED" -gt 0 ]; then
                      COMPLETED_COUNT=$((COMPLETED_COUNT + 1))
                      COMPLETED_LIST="${COMPLETED_LIST}${PROBLEM_ID}(${PROBLEM_COMPLETED}/${SEQ_COUNT}), "
                      if ! echo ",$NOTIFIED_PROBLEMS," | grep -q ",${PROBLEM_ID},"; then
                        NEW_COMPLETED_LIST="${NEW_COMPLETED_LIST}${PROBLEM_ID}, "
                      fi
                    fi
                    if [ "$PROBLEM_FAILED" -gt 0 ]; then
                      FAILED_COUNT=$((FAILED_COUNT + 1))
                      FAILED_LIST="${FAILED_LIST}${PROBLEM_ID}(${PROBLEM_FAILED}/${SEQ_COUNT} failed), "
                    fi
                  else
                    PENDING_LIST="${PENDING_LIST}${PROBLEM_ID}(${PROBLEM_PENDING} pending), "
                  fi
                else
                  # Legacy: check problem_dir directly
                  if find "$problem_dir" -maxdepth 2 -name "*_model.cif" -type f 2>/dev/null | head -1 | grep -q .; then
                    COMPLETED_COUNT=$((COMPLETED_COUNT + 1))
                    COMPLETED_LIST="${COMPLETED_LIST}${PROBLEM_ID}, "
                    if ! echo ",$NOTIFIED_PROBLEMS," | grep -q ",${PROBLEM_ID},"; then
                      NEW_COMPLETED_LIST="${NEW_COMPLETED_LIST}${PROBLEM_ID}, "
                    fi
                  else
                    JOB_NAME="${SUBMISSION_ID}_${PROBLEM_ID}"
                    JOB_STATUS=$(sacct --name="$JOB_NAME" --format=State --noheader 2>/dev/null | head -1 | tr -d ' ')

                    if [ "$JOB_STATUS" = "FAILED" ] || [ "$JOB_STATUS" = "CANCELLED" ] || [ "$JOB_STATUS" = "TIMEOUT" ]; then
                      FAILED_COUNT=$((FAILED_COUNT + 1))
                      FAILED_LIST="${FAILED_LIST}${PROBLEM_ID} (${JOB_STATUS}), "
                    else
                      PENDING_LIST="${PENDING_LIST}${PROBLEM_ID}, "
                    fi
                  fi
                fi
              done

              # Remove trailing commas
              COMPLETED_LIST=$(echo "$COMPLETED_LIST" | sed 's/, $//')
              FAILED_LIST=$(echo "$FAILED_LIST" | sed 's/, $//')
              PENDING_LIST=$(echo "$PENDING_LIST" | sed 's/, $//')
              NEW_COMPLETED_LIST=$(echo "$NEW_COMPLETED_LIST" | sed 's/, $//')

              echo "  Completed: $COMPLETED_COUNT/$TOTAL_PROBLEMS ($COMPLETED_LIST)"
              echo "  Newly completed: $NEW_COMPLETED_LIST"
              echo "  Failed: $FAILED_COUNT ($FAILED_LIST)"
              echo "  Pending: ($PENDING_LIST)"

              # Check if we should process this submission
              # INCREMENTAL_NOTIFICATIONS=false: only when all done or failures with no pending
              # INCREMENTAL_NOTIFICATIONS=true: on each new completion
              SHOULD_PROCESS=false
              if [ "$INCREMENTAL_NOTIFICATIONS" = "true" ]; then
                # Incremental mode: process if any new completions
                if [ -n "$NEW_COMPLETED_LIST" ] || [ "$FAILED_COUNT" -gt 0 ]; then
                  SHOULD_PROCESS=true
                fi
              else
                # Non-incremental mode: only process when all done or all finished (with failures)
                if [ "$COMPLETED_COUNT" -ge "$TOTAL_PROBLEMS" ]; then
                  SHOULD_PROCESS=true
                elif [ "$FAILED_COUNT" -gt 0 ] && [ -z "$PENDING_LIST" ]; then
                  SHOULD_PROCESS=true
                fi
              fi

              if [ "$SHOULD_PROCESS" = "false" ]; then
                echo "  Waiting for more completions (incremental=$INCREMENTAL_NOTIFICATIONS)..."
                continue
              fi

              # Package results
              if [ "$COMPLETED_COUNT" -gt 0 ]; then
                echo "Packaging results..."
                python3 scripts/package_results.py \
                  --submission-dir "$dir" \
                  --output-dir "${PUBLIC_RESULTS}" \
                  --status-file "$STATUS_FILE" \
                  --incremental || true

                TOKEN=$(python3 -c "import json; print(json.load(open('$STATUS_FILE')).get('result_token', ''))" 2>/dev/null)

                if [ -n "$TOKEN" ]; then
                  echo "Results packaged with token: $TOKEN"
                  mkdir -p docs/results/${TOKEN}
                  cp -r ${PUBLIC_RESULTS}/${TOKEN}/* docs/results/${TOKEN}/
                  RESULTS_UPDATED=true

                  # Mark as completed if all problems done (do this AFTER copy succeeds)
                  if [ "$COMPLETED_COUNT" -ge "$TOTAL_PROBLEMS" ]; then
                    python3 -c "import json; f=open('$STATUS_FILE'); d=json.load(f); f.close(); d['status']='completed'; f=open('$STATUS_FILE','w'); json.dump(d,f,indent=2); f.close()"
                    echo "Marked submission as completed"
                  fi
                fi
              fi

              # Comment results on issue
              if [ -n "$ISSUE_NUMBER" ] && [ -n "$TOKEN" ]; then
                if [ "$COMPLETED_COUNT" -ge "$TOTAL_PROBLEMS" ]; then
                  echo "Posting FINAL results comment on issue #$ISSUE_NUMBER"
                  gh issue comment "$ISSUE_NUMBER" --body "## All Results Ready

          All $COMPLETED_COUNT of your AlphaFold3 structure predictions are complete.

          **Completed:** $COMPLETED_LIST

          **View results:** [${SITE_URL}/viewer.html?token=${TOKEN}](${SITE_URL}/viewer.html?token=${TOKEN})
          **Download files:** [${SITE_URL}/results/${TOKEN}/](${SITE_URL}/results/${TOKEN}/)" || true
                  gh issue edit "$ISSUE_NUMBER" --add-label "completed" || true
                  echo "Processed submission: $SUBMISSION_ID"
                elif [ "$INCREMENTAL_NOTIFICATIONS" = "true" ] && [ -n "$NEW_COMPLETED_LIST" ]; then
                  echo "Posting PROGRESS comment on issue #$ISSUE_NUMBER"
                  gh issue comment "$ISSUE_NUMBER" --body "## Progress Update ($COMPLETED_COUNT/$TOTAL_PROBLEMS)

          **Completed:** $COMPLETED_COUNT/$TOTAL_PROBLEMS ($COMPLETED_LIST)
          **Just finished:** $NEW_COMPLETED_LIST
          **Still running:** $PENDING_LIST

          **View results:** [${SITE_URL}/viewer.html?token=${TOKEN}](${SITE_URL}/viewer.html?token=${TOKEN})" || true
                  echo "Processed submission: $SUBMISSION_ID"
                fi
              fi

              # Handle failures (only when no more pending jobs)
              if [ "$FAILED_COUNT" -gt 0 ] && [ -z "$PENDING_LIST" ]; then
                echo "Some problems failed..."
                python3 -c "import json; f=open('$STATUS_FILE'); d=json.load(f); f.close(); d['status']='notified_partial'; d['failed']='$FAILED_LIST'; f=open('$STATUS_FILE','w'); json.dump(d,f,indent=2); f.close()"

                if [ -n "$ISSUE_NUMBER" ]; then
                  BODY="## Results Ready (with errors)

          **Completed ($COMPLETED_COUNT):** $COMPLETED_LIST
          **Failed ($FAILED_COUNT):** $FAILED_LIST"
                  if [ -n "$TOKEN" ]; then
                    BODY="${BODY}

          **View completed results:** [${SITE_URL}/viewer.html?token=${TOKEN}](${SITE_URL}/viewer.html?token=${TOKEN})"
                  fi
                  BODY="${BODY}

          You may resubmit failed problems if needed."
                  gh issue comment "$ISSUE_NUMBER" --body "$BODY" || true
                  gh issue edit "$ISSUE_NUMBER" --add-label "error" || true
                fi
              fi

            else
              # Single-problem submission (backward compatibility)
              MODEL_FILE=$(find "$dir" -maxdepth 2 -name "*_model.cif" -type f 2>/dev/null | head -1)
              if [ -n "$MODEL_FILE" ]; then
                echo "Found completed output: $MODEL_FILE"
                python3 scripts/package_results.py \
                  --submission-dir "$dir" \
                  --output-dir "${PUBLIC_RESULTS}" \
                  --status-file "$STATUS_FILE"

                TOKEN=$(python3 -c "import json; print(json.load(open('$STATUS_FILE')).get('result_token', ''))" 2>/dev/null)

                if [ -n "$TOKEN" ]; then
                  echo "Results packaged with token: $TOKEN"
                  mkdir -p docs/results/${TOKEN}
                  cp -r ${PUBLIC_RESULTS}/${TOKEN}/* docs/results/${TOKEN}/
                  RESULTS_UPDATED=true

                  # Comment on issue if available
                  if [ -n "$ISSUE_NUMBER" ]; then
                    gh issue comment "$ISSUE_NUMBER" --body "## Results Ready

          Your AlphaFold3 structure prediction is complete!

          **View results:** [${SITE_URL}/viewer.html?token=${TOKEN}](${SITE_URL}/viewer.html?token=${TOKEN})
          **Download files:** [${SITE_URL}/results/${TOKEN}/](${SITE_URL}/results/${TOKEN}/)" || true
                    gh issue edit "$ISSUE_NUMBER" --add-label "completed" || true
                  fi

                  echo "Processed submission: $SUBMISSION_ID"
                fi
              fi
            fi
          done

          echo "results_updated=$RESULTS_UPDATED" >> $GITHUB_OUTPUT

      - name: Update leaderboard
        if: steps.check.outputs.results_updated == 'true'
        run: |
          echo "Updating leaderboard data..."

          # Define reference files for each problem (updated for new problems)
          TARGETS_DIR="${GITHUB_WORKSPACE}/docs/targets"
          RESULTS_DIR="${GITHUB_WORKSPACE}/docs/results"

          # Read problem refs dynamically from config.json
          CONFIG_FILE="${GITHUB_WORKSPACE}/docs/targets/config.json"
          declare -A PROBLEM_REFS
          while IFS= read -r line; do
            PID=$(echo "$line" | python3 -c "import sys,json; print(json.load(sys.stdin)['id'])")
            TF=$(echo "$line" | python3 -c "import sys,json; print(json.load(sys.stdin)['target_file'])")
            PT=$(echo "$line" | python3 -c "import sys,json; print(json.load(sys.stdin).get('type','monomer'))")
            PROBLEM_REFS["$PID"]="${TF}:${PT}"
          done < <(python3 -c "import json; [print(json.dumps(p)) for p in json.load(open('$CONFIG_FILE'))['problems']]")

          # Run evaluation for each result directory
          for token_dir in ${RESULTS_DIR}/*/; do
            [ ! -d "$token_dir" ] && continue
            TOKEN=$(basename "$token_dir")
            [ "$TOKEN" = ".gitkeep" ] && continue

            # Get participant ID
            SUBMISSION_FILE="${token_dir}/submission.json"
            [ ! -f "$SUBMISSION_FILE" ] && continue

            PARTICIPANT_ID=$(python3 -c "import json; print(json.load(open('$SUBMISSION_FILE')).get('participant_id', 'unknown'))" 2>/dev/null || echo "unknown")

            # Check each problem
            for problem_id in "${!PROBLEM_REFS[@]}"; do
              REF_INFO="${PROBLEM_REFS[$problem_id]}"
              REF_FILE="${REF_INFO%:*}"
              PROBLEM_TYPE="${REF_INFO#*:}"

              # Find all model files for this problem (supports multi-sequence: _seq1, _seq2, etc.)
              MODEL_FILES=$(find "$token_dir" -name "*${problem_id}*_model.cif" 2>/dev/null | sort)
              [ -z "$MODEL_FILES" ] && continue

              for MODEL_FILE in $MODEL_FILES; do
                # Extract sequence number if present (e.g., problem_1_seq2_model.cif -> seq2)
                MODEL_NAME=$(basename "$MODEL_FILE")
                SEQ_SUFFIX=""
                SEQ_ID=""
                if echo "$MODEL_NAME" | grep -q "_seq[0-9]"; then
                  SEQ_SUFFIX=$(echo "$MODEL_NAME" | grep -oP '_seq\d+' | head -1)
                  SEQ_ID=$(echo "$SEQ_SUFFIX" | sed 's/^_//')  # Remove leading underscore
                fi

                # Build evaluation file name
                EVAL_FILE="${token_dir}/${PARTICIPANT_ID}_${problem_id}${SEQ_SUFFIX}_evaluation.json"

                # Check if already evaluated
                [ -f "$EVAL_FILE" ] && continue

                echo "Evaluating $TOKEN / $problem_id$SEQ_SUFFIX..."

                # Build seq-id argument if present
                SEQ_ARG=""
                [ -n "$SEQ_ID" ] && SEQ_ARG="--seq-id $SEQ_ID"

                # Run evaluation using TMalign + Python lDDT
                python3 scripts/evaluate_structure.py \
                  --model "$MODEL_FILE" \
                  --reference "${TARGETS_DIR}/${REF_FILE}" \
                  --problem-id "$problem_id" \
                  --problem-type "$PROBLEM_TYPE" \
                  --participant-id "$PARTICIPANT_ID" \
                  --token="$TOKEN" \
                  --result-dir "$token_dir" \
                  --output "$EVAL_FILE" \
                  $SEQ_ARG || echo "Warning: Evaluation failed for $TOKEN/$problem_id$SEQ_SUFFIX"
              done
            done
          done

          # Update leaderboard
          echo "Regenerating leaderboard..."
          python3 scripts/update_leaderboard.py \
            --results-dir "${RESULTS_DIR}" \
            --config "${GITHUB_WORKSPACE}/docs/targets/config.json" \
            --output "${GITHUB_WORKSPACE}/docs/leaderboard_data.json"

          # Update admin index
          echo "Regenerating admin index..."
          python3 scripts/generate_admin_index.py

          echo "Leaderboard update complete"

      - name: Commit and push results
        if: steps.check.outputs.results_updated == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/results/ docs/leaderboard_data.json
          git diff --staged --quiet || git commit -m "Add completed results [skip ci]"
          # Pull any remote changes and retry push up to 3 times
          for i in 1 2 3; do
            git pull --rebase origin main && git push && break
            echo "Push attempt $i failed, retrying..."
            sleep 2
          done
